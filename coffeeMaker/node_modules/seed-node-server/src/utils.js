const _ = require('lodash')

/**
 * Returns true if nodeInfo has all required fields, otherwise false
 * Required fields:
 *   nodeInfo = {
 *     externalIp: '127.0.0.1',
 *     externalPort: '9001'
 *   }
 */
function isValidNodeInfo (nodeInfo) {
  // if (!exists(nodeInfo.publicKey)) return false
  if (!exists(nodeInfo.externalIp)) return false
  if (!exists(nodeInfo.externalPort)) return false
  return true
}

/**
 * Returns true if node has all required fields, otherwise false
 * Required fields:
 *   node = {
 *     ip: '127.0.0.1',
 *     port: '9001'
 *   }
 */
function isValidNode (node) {
  if (!exists(node.ip)) return false
  if (!exists(node.port)) return false
  return true
}

/**
 * Returns a parsed object to include in the node list
 * Throws an error if nodeInfo does not have all required fields
 */
function parseNodeInfo (nodeInfo) {
  try {
    const { externalIp, externalPort } = nodeInfo
    const parsedNode = { ip: externalIp, port: externalPort }
    return parsedNode
  } catch (e) {
    throw new Error('nodeInfo does not have all required fields: ' + e)
  }
}

/**
 * Returns false if thing is null or undefined, otherwise true
 */
function exists (thing) {
  return typeof thing !== 'undefined' && thing !== null
}

/**
 * Returns a time string in the format "HH:MM:SS.mmm"
 */
function getISOTime () {
  return new Date().toISOString().split('T')[1]
}

/**
 * Returns an array of two arrays, one will all resolved promises, and one with
 * all rejected promises
 */
async function robustPromiseAll (promises) {
  // This is how we wrap a promise to prevent it from rejecting directing in the Promise.all and causing a short circuit
  const wrapPromise = async (promise) => {
    // We are trying to await the promise, and catching any rejections
    // We return an array, the first index being resolve, and the second being an error
    try {
      const result = await promise
      return [result]
    } catch (e) {
      return [null, e]
    }
  }

  const wrappedPromises = []
  // We wrap all the promises we received and push them to an array to be Promise.all'd
  for (const promise of promises) {
    wrappedPromises.push(wrapPromise(promise))
  }
  const resolved = []
  const errors = []
  // We await the wrapped promises to finish resolving or rejecting
  const wrappedResults = await Promise.all(wrappedPromises)
  // We iterate over all the results, checking if they resolved or rejected
  for (const wrapped of wrappedResults) {
    const [result, err] = wrapped
    // If there was an error, we push it to our errors array
    if (err) {
      errors.push(err)
      continue
    }
    // Otherwise, we were able to resolve so we push it to the resolved array
    resolved.push(result)
  }
  // We return two arrays, one of the resolved promises, and one of the errors
  return [resolved, errors]
}

/**
 * Returns the union of the given node lists.
 * @param {Array} lists
 */
function unionLists (lists) {
  return _.unionBy(...lists, node => node.ip + ':' + node.port)
}

exports.isValidNodeInfo = isValidNodeInfo
exports.isValidNode = isValidNode
exports.parseNodeInfo = parseNodeInfo
exports.exists = exists
exports.getISOTime = getISOTime
exports.robustPromiseAll = robustPromiseAll
exports.unionLists = unionLists
